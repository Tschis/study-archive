<!--

    The MIT License
    Copyright (c) 2017 Rodolfo Forte

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.

-->
<!DOCTYPE html>
<html>
  <head>
    <title>Java Collections</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
	  
	  blockquote {
		border-left: 0.3em solid rgba(0,0,0,0.5);
		padding: 0 15px;
		font-style: italic;
	  }
	  
	  img {
		max-width:100%;
	  }

	  .red {
		color: red;
	  }
	  
	  .green {
		color: green;
	  }
	  
	  .footnote {
		font-style: italic;
		font-size: 14px;
	  }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Java Collections

---

# Main interfaces / Common implementations 

.center[![](images/java-collection-hierarchy.png)]

---

class: center, middle
# Set

---
# Set

* A collection that contains no duplicate elements and at most one null element;

* All constructors must create a set that contains no duplicate elements;

* Some set implementations have restrictions on the elements that they may contain:
  * Some implementations prohibit null elements;
  * Some have restrictions on the types of their elements;
  
* Common implementations:
  * HashSet
  * TreeSet
  * LinkedHashSet
  
---

# TreeSet

* Based on a TreeMap;

* Not synchronized;

* Elements are ordered using their natural ordering, or by a Comparator provided at set creation time;

* Provides guaranteed log(n) time cost for the basic operations (add, remove and contains);

---

# HashSet

* Backed by a HashMap instance;

* Permits the null element;

* Not synchronized;

* Makes no guarantees as to the iteration order of the set; 
  * In particular, it does not guarantee that the order will remain constant over time;

* Offers constant time performance for the basic operations (add, remove, contains and size);

---

# LinkedHashSet

* Hash table and linked list implementation of the Set interface, with predictable iteration order;

* Permits the null element;

* Not synchronized;

* Differs from HashSet because it maintains a doubly-linked list running through all of its entries, so it maintains insertion-order;

* Provides constant-time performance for the basic operations (add, contains and remove);

---

class: center, middle
# List

---

# List

* An ordered collection (a sequence);

* The user has precise control over where in the list each element is inserted, and can access elements by their index (position), or search for elements in the list;

* Unlike sets, lists typically allow duplicate elements, including multiple null elements;

* Some list implementations have restrictions on the elements that they may contain:
  * Some implementations prohibit null elements;
  * Some have restrictions on the types of their elements;

* Common implementations:
  * Vector
  * ArrayList
  * LinkedList
  
---

# Vector

* This class was retrofitted to implement the List interface, making it a member of the Java Collections Framework;

* Is roughly equivalent to ArrayList, except that it is synchronized;
  * If a thread-safe implementation is not needed, it is recommended to use ArrayList;

---

# ArrayList

* Implements a growable array of objects;

* Like an array, it contains components that can be accessed using an integer index;

* The size can grow as needed to accommodate adding items after the ArrayList has been created;

* Operations size, isEmpty, get, set, iterator, and listIterator run in constant time;
  * The add operation runs in amortized constant time;
  * All of the other operations run in linear time (roughly);	

* Each ArrayList instance has a capacity;
  * The capacity is always at least as large as the list size; 
  * As elements are added, its capacity grows automatically;

---

# LinkedList

* Doubly-linked list implementation of the List and Deque interfaces;

* Not synchronized;

* Implements all optional list operations, and permits all elements (including null);

<br />

.center[![](images/doubly-linked-list.png)]

---

class: center, middle
# Queue

---

# Queue

* A collection designed for holding elements prior to processing;

* Provide additional insertion, extraction, and inspection operations;
  * Each of these exists in two forms: one throws an exception if the operation fails, the other returns a special value (null or false);

* Every Queue implementation must specify its ordering properties;
  
* Queues typically, but do not necessarily, order elements in a FIFO manner, where all new elements are inserted at the tail of the queue; 
  * Priority queues order elements according to a supplied comparator, or the elements' natural ordering;
  * Stacks are LIFO queues, ordering the elements in a LIFO manner;
  
* The head of the queue is always that element which would be removed by a call to remove() or poll();

---

# PriorityQueue

* Does not permit null elements;

* Not synchronized;

* The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time;

* The head is the least element with respect to the specified ordering;
  * If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily;

* Is unbounded, but has an internal capacity;
  * Capacity is always at least as large as the queue size;
  * As elements are added, its capacity grows automatically;

* Provides: 
  * O(log(n)) time for offer, poll, remove and add methods;
  * Linear time for the remove(Object) and contains(Object) methods; 
  * Constant time for the retrieval methods (peek, element, and size)
  
---

class: center, middle

# Comparisons 
## ArrayList vs LinkedList

---

# ArrayList vs LinkedList

* LinkedList implements List with a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list):
  * Allows for constant-time insertions or removals using iterators;
  
  * Only sequential access of elements;
  
  * You can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list;

* ArrayList implements List with a dynamically re-sizing array:
  * Allows constant time random read access;
  
  * Adding/removing from anywhere but the end requires shifting all the latter elements over;
  
  * When the capacity of the underlying array is exceeded, a bigger array is allocated;
      * This resizing makes add operations O(n) at worst case, but constant on average;

---

# LinkedList Complexities

* get(int index) is O(n) average;

* .green[add(E element) is O(1);]

* add(int index, E element) is O(n) average;
	
* remove(int index) is O(n) average;

* .green[Iterator.remove() is O(1);]

* .green[ListIterator.add(E element) is O(1);]
  
---

# ArrayList Complexities

* .green[get(int index) is O(1);]

* .green[add(E element) is O(1) amortized];
  * O(n) worst-case, while resizing array;
  
* add(int index, E element) is O(n) average;

* remove(int index) is O(n) average;

* Iterator.remove() is O(n) average;

* ListIterator.add(E element) is O(n) average;

---

# ArrayList vs LinkedList Complexities

<br /><br /><br />

.center[![](images/complexity-arraylist-vs-linkedlist.png)]

---

class: center, middle

# Comparisons 
## HashSet vs TreeSet

---

# HashSet vs TreeSet

* Both implementations are not synchronized;

* Both garantee duplicate-free collections of elements;

* HashSet is faster than TreeSet;
  * O(1) for operations like add, remove and contains;

* TreeSet guarantees that elements will be sorted;
  * Ascending natural order, or using a comparator specified via constructor;
  * The cost is O(log n) complexity for basic operations like add, remove and contains;

---


# HashSet vs TreeSet Complexities

<br /><br /><br />

.center[![](images/complexity-hashset-vs-treeset.png)]

---

# Credits

* [Oracle - Collections Framework Overview](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html)
* [StackOverflow](https://stackoverflow.com)
  * [When to use LinkedList over ArrayList?](https://stackoverflow.com/a/322742/7976727)
  * [What are the time complexities of various data structures?](https://stackoverflow.com/a/7294635/7976727)
  * [Hashset vs Treeset](https://stackoverflow.com/a/4464394/7976727)
* [Big-O Cheat Sheet](http://bigocheatsheet.com/)
* [Wikipedia - Doubly Linked List](https://en.wikipedia.org/wiki/Doubly_linked_list)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>