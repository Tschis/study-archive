<!--

    The MIT License
    Copyright (c) 2017 Rodolfo Forte

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.

-->
<!DOCTYPE html>
<html>
  <head>
    <title>Java Collections</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
	  
	  blockquote {
		border-left: 0.3em solid rgba(0,0,0,0.5);
		padding: 0 15px;
		font-style: italic;
	  }
	  
	  img {
		max-width:100%;
	  }

	  .red {
		color: red;
	  }
	  
	  .green {
		color: green;
	  }
	  
	  .footnote {
		font-style: italic;
		font-size: 14px;
	  }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Java Collections

---

# Main interfaces

<br /><br /><br /><br />

.center[![](images/colls-coreInterfaces.png)]

---

class: center, middle
# java.util.Collection

---

# Collection

* A collection is an object that represents a group of objects;

* The Collections Framework is a unified architecture for representing and manipulating collections;
  * Enables collections to be manipulated independently of implementation details;

* The primary advantages of a collections framework are that it:

  * Reduces programming effort by providing data structures and algorithms so you don't have to write them yourself;
  
  * Provides high-performance implementations of data structures and algorithms;

???

* Because the various implementations of each interface are interchangeable, programs can be tuned by switching implementations;

---

# Collection  
  
* The primary advantages of a collections framework are that it:
  * Provides interoperability between unrelated APIs;
  
  * Reduces the effort required to learn or to design and implement ad hoc APIs;
  
  * Fosters software reuse by providing a standard interface for collections and algorithms with which to manipulate them;

???

* Provides interoperability: by establishing a common language to pass collections back and forth;

* Reduces the effort: by not requiring you to learn and produce your own ad hoc collections APIs;

---

# Collection 

* Many modification methods in the interfaces are labeled optional;
  
* The documentation for each implementation must specify which optional operations are supported;

* Several terms are introduced to aid in this specification:

  * Collections that do not support modification operations are referred to as "unmodifiable", the counterpart being "modifiable";
  
  * Collections that guarantee that no change in the collection object will be visible are referred to as "immutable", the counterpart being "mutable";

???

* Optional: implementations are permitted to not perform one or more of these operations, throwing a runtime exception (UnsupportedOperationException) if they are attempted;

* Modification operations such as add, remove and clear;

---

# Collection 

* Several terms are introduced to aid in this specification:  

  * Lists that guarantee that their size remains constant even though the elements can change are referred to as "fixed-size", the counterpart being "variable-size";
  
  * Lists that support fast (generally constant time) indexed element access are known as random access lists, the counterpart being "sequential access lists";
      * The RandomAccess marker interface enables lists to advertise the fact that they support random access;
      * This enables generic algorithms to change their behavior to provide good performance when applied to either random or sequential access lists;  
      
---

class: center, middle
# Set

---
# Set

* A collection that contains no duplicate elements and at most one null element;

* All constructors must create a set that contains no duplicate elements;

* Some set implementations have restrictions on the elements that they may contain:
  * Some implementations prohibit null elements;
  * Some have restrictions on the types of their elements;
  
* Common implementations:
  * HashSet
  * TreeSet
  * LinkedHashSet
  
---

# TreeSet

* Based on a TreeMap;

* Not synchronized;

* Elements are ordered using their natural ordering, or by a Comparator provided at set creation time;

* Provides guaranteed log(n) time cost for the basic operations (add, remove and contains);

---

# HashSet

* Backed by a HashMap instance;

* Permits the null element;

* Not synchronized;

* Makes no guarantees as to the iteration order of the set; 
  * In particular, it does not guarantee that the order will remain constant over time;

* Offers constant time performance for the basic operations (add, remove, contains and size);

---

# LinkedHashSet

* Hash table and linked list implementation of the Set interface, with predictable iteration order;

* Permits the null element;

* Not synchronized;

* Differs from HashSet because it maintains a doubly-linked list running through all of its entries, so it maintains insertion-order;

* Provides constant-time performance for the basic operations (add, contains and remove);

---

class: center, middle
# List

---

# List

* An ordered collection (a sequence);

* The user has precise control over where in the list each element is inserted, and can access elements by their index (position), or search for elements in the list;

* Unlike sets, lists typically allow duplicate elements, including multiple null elements;

* Some list implementations have restrictions on the elements that they may contain:
  * Some implementations prohibit null elements;
  * Some have restrictions on the types of their elements;

* Common implementations:
  * Vector
  * ArrayList
  * LinkedList
  
---

# Vector

* This class was retrofitted to implement the List interface, making it a member of the Java Collections Framework;

* Is roughly equivalent to ArrayList, except that it is synchronized;
  * If a thread-safe implementation is not needed, it is recommended to use ArrayList;

---

# ArrayList

* Implements a growable array of objects;

* Like an array, it contains components that can be accessed using an integer index;

* The size can grow as needed to accommodate adding items after the ArrayList has been created;

* Operations size, isEmpty, get, set, iterator, and listIterator run in constant time;
  * The add operation runs in amortized constant time;
  * All of the other operations run in linear time (roughly);	

* Each ArrayList instance has a capacity;
  * The capacity is always at least as large as the list size; 
  * As elements are added, its capacity grows automatically;

---

# LinkedList

* Doubly-linked list implementation of the List and Deque interfaces;

* Not synchronized;

* Implements all optional list operations, and permits all elements (including null);

<br />

.center[![](images/doubly-linked-list.png)]

---

class: center, middle
# Queue

---

# Queue

* A collection designed for holding elements prior to processing;

* Provide additional insertion, extraction, and inspection operations;
  * Each of these exists in two forms: one throws an exception if the operation fails, the other returns a special value (null or false);

* Every Queue implementation must specify its ordering properties;
  
* Queues typically, but do not necessarily, order elements in a FIFO manner, where all new elements are inserted at the tail of the queue; 
  * Priority queues order elements according to a supplied comparator, or the elements' natural ordering;
  * Stacks are LIFO queues, ordering the elements in a LIFO manner;
  
* The head of the queue is always that element which would be removed by a call to remove() or poll();

---

# PriorityQueue

* Does not permit null elements;

* Not synchronized;

* The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time;

* The head is the least element with respect to the specified ordering;
  * If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily;

* Is unbounded, but has an internal capacity;
  * Capacity is always at least as large as the queue size;
  * As elements are added, its capacity grows automatically;

* Provides: 
  * O(log(n)) time for offer, poll, remove and add methods;
  * Linear time for the remove(Object) and contains(Object) methods; 
  * Constant time for the retrieval methods (peek, element, and size)

---

class: center, middle
# Deque

---

# Deque

* Linear collection that supports insertion and removal at both ends;

* Name is short for "double ended queue", usually pronounced "deck";

* Extends the Queue interface;
  * When a deque is used as a queue, FIFO behavior results;
  
* Deques can also be used as LIFO stacks;
  * Should be used in preference to the legacy Stack class;

* Provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence;

* Unlike the List interface, it does not provide support for indexed access to elements;

* LinkedList is the most popular implementation;

---

class: center, middle

# Comparisons 
## ArrayList vs LinkedList

---

# ArrayList vs LinkedList

* LinkedList implements List with a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list):
  * Allows for constant-time insertions or removals using iterators;
  
  * Only sequential access of elements;
  
  * You can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list;

* ArrayList implements List with a dynamically re-sizing array:
  * Allows constant time random read access;
  
  * Adding/removing from anywhere but the end requires shifting all the latter elements over;
  
  * When the capacity of the underlying array is exceeded, a bigger array is allocated;
      * This resizing makes add operations O(n) at worst case, but constant on average;

---

# LinkedList Complexities

* get(int index) is O(n) average;

* .green[add(E element) is O(1);]

* add(int index, E element) is O(n) average;
	
* remove(int index) is O(n) average;

* .green[Iterator.remove() is O(1);]

* .green[ListIterator.add(E element) is O(1);]
  
---

# ArrayList Complexities

* .green[get(int index) is O(1);]

* .green[add(E element) is O(1) amortized];
  * O(n) worst-case, while resizing array;
  
* add(int index, E element) is O(n) average;

* remove(int index) is O(n) average;

* Iterator.remove() is O(n) average;

* ListIterator.add(E element) is O(n) average;

---

# ArrayList vs LinkedList Complexities

<br /><br /><br />

.center[![](images/complexity-arraylist-vs-linkedlist.png)]

---

class: center, middle

# Comparisons 
## HashSet vs TreeSet

---

# HashSet vs TreeSet

* Both implementations are not synchronized;

* Both garantee duplicate-free collections of elements;

* HashSet is faster than TreeSet;
  * O(1) for operations like add, remove and contains;

* TreeSet guarantees that elements will be sorted;
  * Ascending natural order, or using a comparator specified via constructor;
  * The cost is O(log n) complexity for basic operations like add, remove and contains;

---

# HashSet vs TreeSet Complexities

<br /><br /><br />

.center[![](images/complexity-hashset-vs-treeset.png)]

---

class: center, middle

# Map

---

# Map

* The other collection interfaces are based on java.util.Map and are not true collections, i.e., they do not implement the Collection interface;

* However, they contain collection-view operations, which enables them to be manipulated as collections;

* Map has the following offspring:

---

# Credits

* [Oracle - Collections Framework Overview](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html)
* [StackOverflow](https://stackoverflow.com)
  * [When to use LinkedList over ArrayList?](https://stackoverflow.com/a/322742/7976727)
  * [What are the time complexities of various data structures?](https://stackoverflow.com/a/7294635/7976727)
  * [Hashset vs Treeset](https://stackoverflow.com/a/4464394/7976727)
* [Big-O Cheat Sheet](http://bigocheatsheet.com/)
* [Wikipedia - Doubly Linked List](https://en.wikipedia.org/wiki/Doubly_linked_list)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>